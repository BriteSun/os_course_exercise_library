<!DOCTYPE HTML>
<html lang="en-US" >
    <!-- Start book 说明 -->
    <head>
        <!-- head:start -->
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=11; IE=10; IE=9; IE=8; IE=7; IE=EDGE" />
        <title>wd1129 | 说明</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="$gitbook serve . 运行web服务">
        <meta name="keywords" content="">
        <meta name="generator" content="GitBook 1.5.0">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
        
    
    
    <link rel="next" href="../wd1182/1182.html" />
    
    
    <link rel="prev" href="../wd1115/1115.html" />
    

        <!-- head:end -->
    </head>
    <body>
        <!-- body:start -->
        
    <link rel="stylesheet" href="../gitbook/style.css">
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-plugin-quizzes/quizzes.css">
        
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-plugin-rust-playpen/editor.css">
        
    
        
        <link rel="stylesheet" href="../gitbook/plugins/gitbook-grvis/test.css">
        
    
    

        
    <div class="book" data-level="50" data-basepath=".." data-revision="1445477045953">
    



    <div class="book-body">
        

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_31">
                    
                        <p>管程：实现代码填空、读者优先的应用代码完成；
第四题： 一、 （22分）管程是操作系统提供的一种进程同步机制，利用管程可解决进程间通信时遇到的同步互斥问题。读者-写者问题（Reader-writer
problem）是一个经典的同步问题。写者优先的读者-写者问题是指，假定有多个并发的读进程和写进程都要访问一个共享的数据结构，要求：(1)读写互斥；(2)写
写互斥；(3)允许多个读进程同时访问；(4)只要有写进程提出申请，其后提出申请的读进程就必须等待该写进程完成访问
。下面是ucore中管程机制和写者优先的读者-写者问题的实现代码。请尝试补全其中所缺的代码，以正确实现管程机制和读者-
写者间的读写操作协调。提示：文件“cdt_wf.c”中的补全代码可能需要在一处加多行代码，其他需要补全的代码只需要一行，一共有11个空要填。</p>
<pre class="sh_c"><code>```
    condition.h
    -----------------------------------------------
    …
    typedef struct {
          int numWaiting;
      int valid;
      wait_queue_t wait_queue;
    } condition_t;
    #define cdtid2cdt(cdt_id)                       \
        ((condition_t )((uintptr_t)(cdt_id) + KERNBASE))
    #define cdt2cdtid(cdt)                          \
        ((cdt_t)((uintptr_t)(cdt) - KERNBASE))
    void
    condition_value_init(condition_t cdt) {
      ...(1)...
      cdt-&gt;valid=1;
            wait_queue_init(&amp;(cdt-&gt;wait_queue));
    }
    int
    condition_init(){
      condition_t cdt;
      if ((cdt = kmalloc(sizeof(condition_t))) != NULL) {
        condition_value_init( cdt );
          }
        if (cdt != NULL) {
              return cdt2cdtid(cdt);
          }
      return -E_INVAL;
    }
    int
    condition_free(cdt_t cdt_id) {
          condition_t cdt = cdtid2cdt(cdt_id);
          int ret = -E_INVAL;
          if (cdt != NULL) {
              bool intr_flag;
              local_intr_save(intr_flag);
              {
                    cdt-&gt;valid = 0, ret = 0;
                    wakeup_queue(&amp;(cdt-&gt;wait_queue), WT_INTERRUPTED, 1);
              kfree(cdt);
              }
              local_intr_restore(intr_flag);
          }
      return ret;
    }
    int
    condition_wait(cdt_t cdt_id, klock_t kl_id){
      condition_t cdt = cdtid2cdt(cdt_id);
          bool intr_flag;
          local_intr_save(intr_flag);
      ...(2)...
          wait_t __wait, wait = &amp;__wait;
          ...(3)...
          local_intr_restore(intr_flag);
          sys_unlock(kl_id);
          schedule();
          sys_lock(kl_id);
          //local_intr_save(intr_flag);
          //wait_current_del(&amp;(cdt-&gt;wait_queue), wait);
          //local_intr_restore(intr_flag);
          if (wait-&gt;wakeup_flags != WT_UCONDITION) {
              return wait-&gt;wakeup_flags;
          }
          return 0;
    }
    int
    condition_signal(cdt_t cdt_id){
          condition_t cdt = cdtid2cdt(cdt_id);
          if (cdt == NULL) {
        return -E_INVAL;
      }
      bool intr_flag;
          local_intr_save(intr_flag);
      if (cdt-&gt;numWaiting &gt; 0) {
              wait_t wait;
              if ((wait = wait_queue_first(&amp;(cdt-&gt;wait_queue))) != NULL) {
                    assert(wait-&gt;proc-&gt;wait_state == WT_UCONDITION);
                    ...(4)...
            }
        ...(5)...
          }
          local_intr_restore(intr_flag);
      return 0;
    }
    …
    -----------------------------------------------
    ulib.c
    -----------------------------------------------
    …
    cdt_t
    cdt_init(){
      return sys_cdt_init();
    }
    int
    cdt_signal(cdt_t cdt_id){
      return sys_cdt_signal(cdt_id);
    }
    int
    cdt_wait(cdt_t cdt_id ,klock_t klock_id){
      return sys_cdt_wait(cdt_id ,klock_id);
    }
    int
    cdt_free(cdt_t cdt_id){
      return sys_cdt_free(cdt_id);
    }
    klock_t
    klock_init(){
      return sys_klock_init();
    }
    int
    klock_aquire(klock_t klock_id){
      return sys_klock_aquire(klock_id);
    }
    int
    klock_release(klock_t klock_id){
      return sys_klock_release(klock_id);
    }
    int
    klock_free(klock_t klock_id){
      return sys_klock_free(klock_id);
    }
    …
    -----------------------------------------------
    cdt_wf.c
    -----------------------------------------------
    …
    int active_reader ;    // # count of active readers
    int active_writer ;  // # count of active writers
    int waiting_reader ;   // # count of waiting readers
    int waiting_writer ;   // # count of waiting writers
    cdt_t cdt_okToRead;
    cdt_t cdt_okToWrite;
    klock_t lock;
    void
    failed(void) {
        cprintf(&quot;FAIL: T.T
&quot;);
        exit(-1);
    }
    void
    init(void) {
        if ((cdt_okToRead = cdt_init()) &lt; 0 || (cdt_okToWrite = cdt_init()) &lt; 0) {
            failed();
        }
        if ((lock = klock_init()) &lt; 0) {
            failed();
        }
        if ((active_reader = shmem_malloc(sizeof(int))) == NULL || (active_writer = shmem_malloc(sizeof(int))) == NULL
      || (waiting_reader = shmem_malloc(sizeof(int))) == NULL || (waiting_writer = shmem_malloc(sizeof(int))) == NULL) {
            failed();
        }
        active_reader = active_writer = waiting_reader = waiting_writer = 0;
    }
    void
    check_init_value(void) {
        if (cdt_okToRead &lt; 0 || cdt_okToWrite &lt; 0 ) {
      failed();
        }
        if (lock &lt; 0 ) {
            failed();
        }
        if (active_reader != 0 || active_writer != 0 || waiting_reader != 0 || waiting_writer != 0) {
            failed();
        }
    }
    void
    free_wf(void){
      if (  cdt_free(cdt_okToRead) &lt; 0 ||  cdt_free(cdt_okToWrite) &lt; 0 ){
        scprintf(&quot; conditon free failed! 
&quot;);
        exit(-1);
      }
      if (  klock_free(lock) &lt; 0 ){
        scprintf(&quot; kernal lock free failed! 
&quot;);
        exit(-1);
      }
    }
    void
    start_read(void) {
      klock_aquire(lock);
            ...(6)...
            klock_release(lock);
    }
    void
    done_read(void) {
      klock_aquire(lock);
            ...(7)...
      klock_release(lock);
    }
    void
    start_write(void) {
      klock_aquire(lock);
            ...(8)...
      klock_release(lock);
    }
    void
    done_write(void) {
      klock_aquire(lock);
            ...(9)...
            if ((waiting_writer) &gt; 0) {
                 ...(10)...
            }
            else if ((waiting_reader) &gt; 0) {
        int wakecount=0;
        while(...(11)...){
          cdt_signal(cdt_okToRead);
          wakecount++;
        }
            }
      klock_release(lock);
    }
    void
    writer(int id, int time) {
      scprintf(&quot;writer %d: (pid:%d) arrive 
&quot;, id, getpid());
            start_write();
            scprintf(&quot;    writer_wf %d: (pid:%d) start %d
&quot;, id, getpid(), time);
          sleep(time);
          scprintf(&quot;    writer_wf %d: (pid:%d) end %d
&quot;, id, getpid(), time);
            done_write();
    }
    void
    reader(int id, int time) {
          scprintf(&quot;reader %d: (pid:%d) arrive
&quot;, id, getpid());
        start_read();
          scprintf(&quot;    reader_wf %d: (pid:%d) start %d
&quot;, id, getpid(), time);
          sleep(time);
          scprintf(&quot;    reader_wf %d: (pid:%d) end %d
&quot;, id, getpid(), time);
      done_read();
    }
    void
    read_test_wf(void) {
    …
    }
    void
    write_test_wf(void) {
    …
    }
    void
    read_write_test_wf(void) {
    …
    }
    int
    main(void) {
        init();
        read_test_wf();
        write_test_wf();
        read_write_test_wf();
        free_wf();
        cprintf(&quot;condition reader_writer_wf_test pass..
&quot;);
        return 0;
    }
    -----------------------------------------------
    wait.c
    -----------------------------------------------
    …
    void
    wait_init(wait_t wait, struct proc_struct proc) {
        wait-&gt;proc = proc;
        wait-&gt;wakeup_flags = WT_INTERRUPTED;
        list_init(&amp;(wait-&gt;wait_link));
    }
    void
    wait_queue_init(wait_queue_t queue) {
        list_init(&amp;(queue-&gt;wait_head));
    }
    void
    wait_queue_add(wait_queue_t queue, wait_t wait) {
        assert(list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;proc != NULL);
        wait-&gt;wait_queue = queue;
        list_add_before(&amp;(queue-&gt;wait_head), &amp;(wait-&gt;wait_link));
    }
    void
    wait_queue_del(wait_queue_t queue, wait_t wait) {
        assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == queue);
        list_del_init(&amp;(wait-&gt;wait_link));
    }
    wait_t 
    wait_queue_next(wait_queue_t queue, wait_t wait) {
        assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == queue);
        list_entry_t le = list_next(&amp;(wait-&gt;wait_link));
        if (le != &amp;(queue-&gt;wait_head)) {
            return le2wait(le, wait_link);
        }
        return NULL;
    }
    wait_t 
    wait_queue_prev(wait_queue_t queue, wait_t wait) {
        assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == queue);
        list_entry_t le = list_prev(&amp;(wait-&gt;wait_link));
        if (le != &amp;(queue-&gt;wait_head)) {
            return le2wait(le, wait_link);
        }
        return NULL;
    }
    wait_t 
    wait_queue_first(wait_queue_t queue) {
        list_entry_t le = list_next(&amp;(queue-&gt;wait_head));
        if (le != &amp;(queue-&gt;wait_head)) {
            return le2wait(le, wait_link);
        }
        return NULL;
    }
    wait_t 
    wait_queue_last(wait_queue_t queue) {
        list_entry_t le = list_prev(&amp;(queue-&gt;wait_head));
        if (le != &amp;(queue-&gt;wait_head)) {
            return le2wait(le, wait_link);
        }
        return NULL;
    }
    bool
    wait_queue_empty(wait_queue_t queue) {
        return list_empty(&amp;(queue-&gt;wait_head));
    }
    bool
    wait_in_queue(wait_t wait) {
        return !list_empty(&amp;(wait-&gt;wait_link));
    }
    void
    wakeup_wait(wait_queue_t queue, wait_t wait, uint32_t wakeup_flags, bool del) {
        if (del) {
            wait_queue_del(queue, wait);
        }
        wait-&gt;wakeup_flags = wakeup_flags;
        wakeup_proc(wait-&gt;proc);
    }
    void
    wakeup_first(wait_queue_t queue, uint32_t wakeup_flags, bool del) {
        wait_t wait;
        if ((wait = wait_queue_first(queue)) != NULL) {
            wakeup_wait(queue, wait, wakeup_flags, del);
        }
    }
    void
    wakeup_queue(wait_queue_t queue, uint32_t wakeup_flags, bool del) {
        wait_t wait;
        if ((wait = wait_queue_first(queue)) != NULL) {
            if (del) {
                do {
                    wakeup_wait(queue, wait, wakeup_flags, 1);
                } while ((wait = wait_queue_first(queue)) != NULL);
            }
            else {
                do {
                    wakeup_wait(queue, wait, wakeup_flags, 0);
                } while ((wait = wait_queue_next(queue, wait)) != NULL);
            }
        }
    }
    void
    wait_current_set(wait_queue_t queue, wait_t wait, uint32_t wait_state) {
        assert(current != NULL);
        wait_init(wait, current);
        current-&gt;state = PROC_SLEEPING;
        current-&gt;wait_state = wait_state;
        wait_queue_add(queue, wait);
    }
    -----------------------------------------------
    proc.h
    -----------------------------------------------
    …
    //the wait state
    #define WT_CHILD        (0x00000001 | WT_INTERRUPTED)  // wait child process
    #define WT_TIMER        (0x00000002 | WT_INTERRUPTED)  // wait timer
    #define WT_KSWAPD       0x00000003                    // wait kswapd to free page
    #define WT_KSEM         0x00000100                    // wait kernel semaphore
    #define WT_USEM         (0x00000101 | WT_INTERRUPTED)  // wait user semaphore
    #define WT_EVENT_SEND  (0x00000110 | WT_INTERRUPTED)  // wait the sending event
    #define WT_EVENT_RECV  (0x00000111 | WT_INTERRUPTED)  // wait the recving event
    #define WT_MBOX_SEND   (0x00000120 | WT_INTERRUPTED)  // wait the sending mbox
    #define WT_MBOX_RECV   (0x00000121 | WT_INTERRUPTED)  // wait the recving mbox
    #define WT_UCONDITION  (0x00000130 | WT_INTERRUPTED)  // wait user condition    --liuruilin
    #define WT_INTERRUPTED 0x80000000 // the wait state could be interrupted
    …
    -----------------------------------------------
    ```
</code></pre><div class="active-code">
<textarea rows="10" cols="80"></textarea>
<div><input class="action-submit" type="submit" value="提交"/></div>
</div>
                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        
        
        
        
        
    </div>
</div>

        
<script src="../gitbook/app.js"></script>

    
    <script src="../gitbook/plugins/gitbook-plugin-quizzes/quizzes.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-rust-playpen/ace/ace.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-rust-playpen/editor.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-rust-playpen/mode-rust.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-grvis/test.js"></script>
    

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

    
    <script src="../gitbook/plugins/gitbook-plugin-livereload/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2},"rust-playpen":{},"grvis":{},"quizees":{}};
    gitbook.start(config);
});
</script>

        <!-- body:end -->
    </body>
    <!-- End of book 说明 -->
</html>
